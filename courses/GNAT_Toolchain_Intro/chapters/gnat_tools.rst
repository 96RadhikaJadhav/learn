GNAT Tools
==========

.. include:: <isopub.txt>

.. include:: <isoamsa.txt>

.. role:: ada(code)
   :language: ada

This chapter presents a brief overview of some tools included in the GNAT
Community toolchain.

For further details on the tools, please refer to the
`GNAT User’s Guide <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn.html>`_.

gnatchop
--------

:program:`gnatchop` is used to rename files in order to match the file
structure expected by the GNAT toolchain.
In order to explain what :program:`gnatchop` does, we need to first
understand the file naming scheme for GNAT. In basic terms, GNAT expects
specifications to be stored in *.ads* files and implementations to be
stored in *.adb* files. Also, it expects the file name to match a naming
scheme according to the content of the individual files. For example, the
specification of a package :ada:`Pkg.Child` must be stored in a file
called ``pkg-child.ads``.

We may, however, have Ada source-code stored in a single file. Consider
that the following code is stored in a file called ``example.ada``:

.. code-block:: ada

    with Ada.Text_IO; use Ada.Text_IO;

    package P is
       procedure Test;
    end P;

    package body P is
       procedure Test is
       begin
          Put_Line("Test passed.");
       end Test;
    end P;

    with P; use P;

    procedure P_Main is
    begin
       P.Test;
    end P_Main;

In order to compile this code, we simply call :program:`gnatchop` for
the source-code file before calling :program:`gprbuild`:

.. code-block:: sh

    gnatchop example.ada
    gprbuild p_main

This generates the source-code files (extracted from ``example_ada``) and
builds the executable binary ``p_main``. In fact, the following files are
created: ``p.ads``, ``p.adb`` and ``p_main.adb``.

In this last example, any warning that the compiler displays refers to
the files generated by :program:`gnatchop`. We may, however, instruct
:program:`gnatchop` to instrument the generated files, so that the
compiler refers to the original file (``example.ada`` in our case) when
displaying messages. This is achieved by using the ``-r`` option:

.. code-block:: sh

    gnatchop -r example.ada
    gprbuild p_main

Now, if we had an unused variable in ``example.ada``, the compiler
warning would refer to the line in the original file, not the generated
one.

For further options available for :program:`gnatchop`, please refer to the
`gnatchop chapter <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/the_gnat_compilation_model.html#renaming-files-with-gnatchop>`_
from the GNAT User’s Guide.

gnatprep
--------

Conditional compilation may be required in many situations. For example,
we might need to use a customized implementation of a package for a
specific platform or select a specific version of an algorithm depending
on the requirements of the target environment. One way to achieve this
is to use a source-code preprocessor. However, in many cases where
conditional compilation is needed, using the syntax of the Ada language
or the functionality provided by :program:`GPRbuild` is sufficient. We
don't really need to use a preprocessor in those cases. The
`conditional compilation section <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/the_gnat_compilation_model.html#conditional-compilation>`_
of the GNAT User's Guide discusses in details how this can be achieved.

In complex cases where using a preprocessor is the most straightforward
option, we may use :program:`gnatprep`, which provides a preprocessing
syntax that reminds of the C and C++ preprocessor. However, in contrast to
C and C++, this syntax is not part of the Ada standard and can only be
used with :program:`gnatprep` alone. Also, you'll encounter some
differences in the syntax, such as in the example below:

.. code-block:: none

    #if VERSION'Defined and then (VERSION >= 4) then
       --  Implementation for version 4.0 and above...
    #else
       --  Standard implementation for older versions...
    #end if;

Note that, for this simple example, we could use the Ada language
directly and avoid the prepocessor altogether. For example:

.. code-block:: ada

    package Config is
       Version : constant Integer := 4;
    end Config;

    with Config;
    procedure Do_Something is
    begin
       if Config.Version >= 4 then
          null;
          --  Implementation for version 4.0 and above...
       else
          null;
          --  Standard implementation for older versions...
       end if;
    end Do_Something;

However, for the sake of simplicity, let's stick with the code snippet
above for the preprocessor. This is the complete implementation stored in
a file called ``do_something.org.adb``:

.. code-block:: none

    procedure Do_Something is
    begin
       #if VERSION'Defined and then (VERSION >= 4) then
       --  Implementation for version 4.0 and above...
       null;
       #else
       --  Standard implementation for older versions...
       null;
       #end if;
    end Do_Something;


In order to preprocess this file and build the application, we can call
:program:`gnatprep` and then :program:`GPRbuild`:

.. code-block:: sh

    gnatprep do_something.org.adb do_something.adb
    gprbuild do_something

If you look into the output file after code stripping, you see that the
``#else`` implementation was selected by :program:`gnatprep`. In order to
select the newer "version" of the code, you may indicate the symbol in
the call to :program:`gnatprep`, similar to what you'd do for the C/C++
preprocessor:

.. code-block:: sh

    gnatprep -DVERSION=5 do_something.org.adb do_something.adb

However, a cleaner approach is to create a symbol definition file
containing all symbols found in our implementation. Let's create the file
and name it ``prep.def``:

.. code-block:: none

    VERSION := 5

Now, we can simply pass it to :program:`gnatprep`:

.. code-block:: sh

    gnatprep do_something.org.adb do_something.adb prep.def
    gprbuild do_something

Using :program:`gnatprep` as above has an impact on the line numbering
of the processed file. In order to preserve line numbering, you might
use one of these command-line options:

    - ``-b``: replace stripped-out code by blank lines
    - ``-c``: comment-out the stripped-out code

For example:

.. code-block:: sh

    gnatprep -b do_something.org.adb do_something.adb prep.def
    gnatprep -c do_something.org.adb do_something.adb prep.def

Using one of these options, the output file ``do_something.adb`` has the
same line numbering as the original file (``do_something.org.adb``).

The `gnatprep chapter <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/the_gnat_compilation_model.html#preprocessing-with-gnatprep>`_.
from the GNAT User’s Guide contains further details about this tool, such as
the integration of :program:`gnatprep` with project files for
:program:`GPRbuild` and replacing of symbols outside of preprocessing
directives (using the ``$symbol`` syntax).

gnatelim
--------

When creating new applications, you may reuse existing frameworks
containing multiple packages. While this approach allows you to quickly
create useful applications, it may result in applications that contain
lots of unused subprograms. For example, your application may use only
two procedures of a package :ada:`P`, which contains 15 procedures and
functions. In this case, the resulting application contains code for
13 unused procedures or functions. This can be especially a problem in
platforms with strict memory contraints.

In order to remove unused code, GNAT provides you with the pragma
:ada:`Eliminate`. When this pragma is used for a specific subprogram,
the compiler doesn't generate code for it, so that the overall code size
is reduce. While this pragma can be used manually in applications, the
task is simplified by using :program:`gnatelim`, which scans source-code
files and determines which subprograms can be safely eliminated.

Let's start with a simple example:

.. code-block:: ada

    package P is
       procedure Test_1;
       procedure Test_2;
    end P;

    with Ada.Text_IO; use Ada.Text_IO;

    package body P is
       procedure Test_1 is
       begin
          Put_Line("Test #1 passed.");
       end Test_1;

       procedure Test_2 is
       begin
          Put_Line("Test #2 passed.");
       end Test_2;
    end P;

.. code-block:: ada

    with P; use P;

    procedure Main_App is
    begin
       P.Test_1;
    end Main_App;


In order to create a list of unused subprograms for our :ada:`Main_App`,
we call :program:`gnatelim` and provide the file containing the main
application (``main_app.adb`` in our case) and the file that we want to
check for unused code. For example:

.. code-block:: sh

    gnatelim -main=main_app.adb p.adb

Running the command above generates the following output:

.. code-block:: none

    ---------------------------------------------------------
    --  List of unused entities to be placed in gnat.adc.  --
    ---------------------------------------------------------
    pragma Eliminate (P, Test_2, Source_Location => "p.ads:3");

This output can be added to the configuration pragma file of our
application. If you use :program:`gnatmake`, naming the configuration
pragma file ``gnat.adc`` indicates to the compiler that this file shall be
used. In our case, let's redirect the output of :program:`gnatelim` and
compile the application with :program:`gnatmake`:

.. code-block:: sh

    gnatelim -main=main_app.adb p.adb > gnat.adc
    gnatmake main_app.adb

We may also associate :program:`gnatelim` with project files for
:program:`GPRbuild`.

.. todo:: Link to upcoming section on configuration files in
          GPRbuild chapter.

Please refer to the
`gnatelim chapter  <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_and_program_execution.html#reducing-size-of-ada-executables-with-gnatelim>`_
from the GNAT User’s Guide contains further options for the tool.

gnatxref and gnatfind
---------------------

The :program:`gnatxref` and :program:`gnatfind` tools are used to
retrieve information about individual syntactical elements from the
source-code (e.g. variable declarations and subprograms). Both tools are
based on the cross-referencing information generated by the compiler and
stored in *.ali*.

Let's reuse the source-code example from the previous section:

.. code-block:: ada

    package P is
       procedure Test_1;
       procedure Test_2;
    end P;

    with Ada.Text_IO; use Ada.Text_IO;

    package body P is
       procedure Test_1 is
       begin
          Put_Line("Test #1 passed.");
       end Test_1;

       procedure Test_2 is
       begin
          Put_Line("Test #2 passed.");
       end Test_2;
    end P;

.. code-block:: ada

    with P; use P;

    procedure Main_App is
    begin
       P.Test_1;
    end Main_App;

After building the application for this example, we can use
:program:`gnatxref` to display elements from individual files:

.. code-block:: sh

    gnatxref p.adb

This generates the following output report:

.. code-block:: none

    Ada                                              package
      Decl:  ada.ads     16:9
      Ref:   p.adb        1:6       1:23
    P                                                package
      Decl:  p.ads        1:9
      Body:  p.adb        3:14
    Put_Line                                         procedure
      Decl:  a-textio.ads         263:14
      Ref:   p.adb        6:7      11:7
    Test_1                                           procedure
      Decl:  p.ads        2:14
      Body:  p.adb        4:14
    Test_2                                           procedure
      Decl:  p.ads        3:14
      Body:  p.adb        9:14
    Text_IO                                          package
      Decl:  a-textio.ads          49:13
      Ref:   p.adb        1:27

Among other things, we get the declaration and body of package :ada:`P`
and the declaration and body of the procedures :ada:`Test_1` and
:ada:`Test_2`. We also get the declaration of :ada:`Put_Line` (from
the :ada:`Ada.Test_IO`) package and its reference in body of package
:ada:`P`.

We can use :program:`gnatfind` to retrieve all references to a specific
pattern we're interested in. For example, let's search for all instances
of :ada:`Test_1`:

.. code-block:: sh

    gnatfind -r Test_1

This generates the following output report:

.. code-block:: none

    p.ads:2:14:           (spec) Test_1
    p.adb:4:14:           (body) Test_1
    main_app.adb:5:6:            Test_1
    p.adb:7:8:                   Test_1

The `chapter on gnatxref and gnatfind <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-cross-referencing-tools-gnatxref-and-gnatfind>`_
from the GNAT User’s Guide contains further examples and command-line
options for these tools.

gnatmem
-------

Mismatches in memory allocation and deallocation are a source of memory
leaks. To test an application for memory allocation issues, we may use
:program:`gnatmem`. This tool monitors all memory allocations that occur
while running the application. This is achieved by linking the
application to a special version of the memory allocation library
(``libgmem.a``).

Let's consider this simple example:

.. code-block:: ada

    procedure Simple_Mem is
       I_Ptr : access Integer := new Integer;
    begin
       null;
    end Simple_Mem;

In order to generate a report for this code, we need to:

    - Build the application by linking it to ``libgmem.a``;

    - Run the application, which generates an output file (``gmem.out``);

    - Run :program:`gnatmem` to process ``gmem.out`` and generate a
      report.

For our example above, these are the steps:

.. code-block:: sh

    # Build application using gmem
    gnatmake -g simple_mem.adb -largs -lgmem

    # Run the application and generate gmem.out
    ./simple_mem

    # Call gnatmem to display the memory report based on gmem.out
    gnatmem simple_mem

For this example, :program:`gnatmem` displays the following information:

.. code-block:: none

    Global information
    ------------------
       Total number of allocations        :   1
       Total number of deallocations      :   0
       Final Water Mark (non freed mem)   : 4 Bytes
       High Water Mark                    : 4 Bytes

    Allocation Root # 1
    -------------------
     Number of non freed allocations    :   1
     Final Water Mark (non freed mem)   : 4 Bytes
     High Water Mark                    : 4 Bytes
     Backtrace                          :
       simple_mem.adb:2 simple_mem

Please refer to the
`chapter on gnatmem <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_and_program_execution.html#the-gnatmem-tool>`_
from the GNAT User’s Guide for a more detailed presentation of this tool.

gnatmetric
----------

The GNAT metric tool (:program:`gnatmetric`) is used to compute a number
of programming metrics. You can use it to compute metrics for individual
files or a complete project.

For example, considering the implementation of the package :ada:`P` above,
we may compute the metrics by running :program:`gnatmetric` as follows:

.. code-block:: sh

    gnatmetric p.adb

This is the output of the tool for this package:

.. code-block:: none

    Line metrics summed over 1 units
      all lines            : 13
      code lines           : 11
      comment lines        : 0
      end-of-line comments : 0
      comment percentage   : 0.00
      blank lines          : 2

    Average lines in body: 4.00

    Element metrics summed over 1 units
      all statements      : 2
      all declarations    : 3
      logical SLOC        : 5

     2 subprogram bodies in 1 units

    Average cyclomatic complexity: 1.00

Please refer to the
`section on gnatmetric <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-gnat-metrics-tool-gnatmetric>`_
from the GNAT User’s Guide for the many options available for
:program:`gnatmetric`, including the generation of reports in XML format.

gnatdoc
-------

:program:`GNATdoc` is used to generate the HTML documentation of a
project. It scans the source-code files in the project and extracts the
most important information, such as package, subprogram and type
declarations.

The simplest usage is by providing the name of the project or calling
:program:`GNATdoc` from a directory where a project file is available:

.. code-block:: sh

    gnatdoc -P default.gpr

    # Alternatively, when the project file is in the same directory:

    gnatdoc

Using this command is sufficient to generate a simple list of the
packages and the corresponding API. However, in order to create a
meaningful documentation, we should add a description of each parameter or
field in the application. For example:

.. code-block:: ada

    package P is
    --  Collection of auxiliary subprograms

       function Add_One
         (V : Integer
          --  Coefficient to be increased
         ) return Integer;
       --  @return Coefficient increased by one

    end P;

.. code-block:: ada

    package body P is

       function Add_One (V : Integer) return Integer is
       begin
          return V + 1;
       end Add_One;

    end P;

.. code-block:: ada

    with P; use P;

    procedure Main is

       I : Integer;

    begin
       I := Add_One (0);
    end Main;

In this example, the documentation is extracted from the specification of
package :ada:`P`. Note that the description of each element is added as a
comment in the line below the actual declaration. :program:`GNATdoc` is
able to extract the package description, which we wrote as a comment in
the line right after :ada:`package P is`. Also, the tool extracts the
documentation of function :ada:`Add_One` (both the description of the
:ada:`V` parameter and of the return value).

In addition to the approach we've just seen, :program:`GNATdoc` also
supports the tagged format |mdash| commonly found in tools such as Javadoc
|mdash| using the ``@`` syntax. The documentation for package :ada:`P`
could be rewritten as follows:

.. code-block:: ada

    package P is
    -- @summary Collection of auxiliary subprograms

       function Add_One
         (V : Integer
         ) return Integer;
       -- @param V Coefficient to be increased
       -- @return Coefficient increased by one

    end P;

It's possible to control what parts of the source-code :program:`GNATdoc`
parses to extract the documentation. For example, the ``-b`` option
indicates that the package body is parsed for additional documentation.
Also, when the ``-p`` option is used,  :program:`GNATdoc` parses the
private part of package specifications. For a complete list of options,
please refer to the
`GNATdoc User Guide <http://docs.adacore.com/gnatdoc-docs/users_guide/_build/html/index.html>`_.

gnat2xml
--------

:program:`gnat2xml` is a tool for generating an XML representation of the
source-code from a project. This XML representation can be used for
source-code analysis, for example. In order to use the tool, you have
to indicate the project file:

.. code-block:: sh

    gnat2xml -P default.gpr > output.xml

Since the XML representation is written to the standard output by default,
we need to redirect it to a file for storage (as in the example above).
In this case, the ``output.xml`` file contains an XML representation of
the complete source-code of our project.

Alternatively, we can generate a corresponding XML file for each
source-code from our project. In order to do that, we use the
``--output-dir`` option:

.. code-block:: sh

    gnat2xml -P default.gpr --output-dir=out_xml

This command generates XML files and stores them in the ``out_xml``
directory.

Let's consider this simple example:

.. code-block:: ada

    procedure Main is

       function Init_2 return Integer is (2);

       I : Integer;

    begin
       I := Init_2;
    end Main;

For this example, :program:`gnat2xml` generates the following XML
representation:

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8" ?>
    <compilation_unit unit_kind="A_Procedure_Body" unit_class="A_Public_Declaration_And_Body" unit_origin="An_Application_Unit" unit_full_name="Main" def_name="Main" source_file="main.adb">
       <sloc line="2" col="1" endline="10" endcol="9"/>
       <context_clause_elements_ql>
       </context_clause_elements_ql>
       <unit_declaration_q>
          <procedure_body_declaration>
             <sloc line="2" col="1" endline="10" endcol="9"/>
             <is_overriding_declaration_q>
                <not_an_element>
                   <sloc line="1" col="1" endline="0" endcol="0"/>
                </not_an_element>
             </is_overriding_declaration_q>
             <is_not_overriding_declaration_q>
                <not_an_element>
                   <sloc line="1" col="1" endline="0" endcol="0"/>
                </not_an_element>
             </is_not_overriding_declaration_q>
             <names_ql>
                <defining_identifier def_name="Main" def="ada://procedure_body/Main+2:11" type="null">
                   <sloc line="2" col="11" endline="2" endcol="14"/>
                </defining_identifier>
             </names_ql>
             <parameter_profile_ql>
             </parameter_profile_ql>
             <aspect_specifications_ql>
             </aspect_specifications_ql>
             <body_declarative_items_ql>
                <expression_function_declaration>
                   <sloc line="4" col="4" endline="4" endcol="41"/>
                   <is_overriding_declaration_q>
                      <not_an_element>
                         <sloc line="1" col="1" endline="0" endcol="0"/>
                      </not_an_element>
                   </is_overriding_declaration_q>
                   <is_not_overriding_declaration_q>
                      <not_an_element>
                         <sloc line="1" col="1" endline="0" endcol="0"/>
                      </not_an_element>
                   </is_not_overriding_declaration_q>
                   <names_ql>
                      <defining_identifier def_name="Init_2" def="ada://expression_function/Main+2:11/Init_2+4:13" type="null">
                         <sloc line="4" col="13" endline="4" endcol="18"/>
                      </defining_identifier>
                   </names_ql>
                   <parameter_profile_ql>
                   </parameter_profile_ql>
                   <is_not_null_return_q>
                      <not_an_element>
                         <sloc line="1" col="1" endline="0" endcol="0"/>
                      </not_an_element>
                   </is_not_null_return_q>
                   <result_profile_q>
                      <identifier ref_name="Integer" ref="ada://ordinary_type/Standard-1:1/Integer-1:1" type="null">
                         <sloc line="4" col="27" endline="4" endcol="33"/>
                      </identifier>
                   </result_profile_q>
                   <result_expression_q>
                      <parenthesized_expression type="ada://ordinary_type/Standard-1:1/Integer-1:1">
                         <sloc line="4" col="38" endline="4" endcol="40"/>
                         <expression_parenthesized_q>
                            <integer_literal type="universal integer" lit_val="2">
                               <sloc line="4" col="39" endline="4" endcol="39"/>
                            </integer_literal>
                         </expression_parenthesized_q>
                      </parenthesized_expression>
                   </result_expression_q>
                   <aspect_specifications_ql>
                   </aspect_specifications_ql>
                </expression_function_declaration>
                <variable_declaration>
                   <sloc line="6" col="4" endline="6" endcol="15"/>
                   <names_ql>
                      <defining_identifier def_name="I" def="ada://variable/Main+2:11/I+6:4" type="ada://ordinary_type/Standard-1:1/Integer-1:1">
                         <sloc line="6" col="4" endline="6" endcol="4"/>
                      </defining_identifier>
                   </names_ql>
                   <has_aliased_q>
                      <not_an_element>
                         <sloc line="1" col="1" endline="0" endcol="0"/>
                      </not_an_element>
                   </has_aliased_q>
                   <object_declaration_view_q>
                      <subtype_indication>
                         <sloc line="6" col="8" endline="6" endcol="14"/>
                         <has_aliased_q>
                            <not_an_element>
                               <sloc line="1" col="1" endline="0" endcol="0"/>
                            </not_an_element>
                         </has_aliased_q>
                         <has_null_exclusion_q>
                            <not_an_element>
                               <sloc line="1" col="1" endline="0" endcol="0"/>
                            </not_an_element>
                         </has_null_exclusion_q>
                         <subtype_mark_q>
                            <identifier ref_name="Integer" ref="ada://ordinary_type/Standard-1:1/Integer-1:1" type="null">
                               <sloc line="6" col="8" endline="6" endcol="14"/>
                            </identifier>
                         </subtype_mark_q>
                         <subtype_constraint_q>
                            <not_an_element>
                               <sloc line="1" col="1" endline="0" endcol="0"/>
                            </not_an_element>
                         </subtype_constraint_q>
                      </subtype_indication>
                   </object_declaration_view_q>
                   <initialization_expression_q>
                      <not_an_element>
                         <sloc line="1" col="1" endline="0" endcol="0"/>
                      </not_an_element>
                   </initialization_expression_q>
                   <aspect_specifications_ql>
                   </aspect_specifications_ql>
                </variable_declaration>
             </body_declarative_items_ql>
             <body_statements_ql>
                <assignment_statement>
                   <sloc line="9" col="4" endline="9" endcol="15"/>
                   <label_names_ql>
                   </label_names_ql>
                   <assignment_variable_name_q>
                      <identifier ref_name="I" ref="ada://variable/Main+2:11/I+6:4" type="ada://ordinary_type/Standard-1:1/Integer-1:1">
                         <sloc line="9" col="4" endline="9" endcol="4"/>
                      </identifier>
                   </assignment_variable_name_q>
                   <assignment_expression_q>
                      <function_call type="ada://ordinary_type/Standard-1:1/Integer-1:1">
                         <sloc line="9" col="9" endline="9" endcol="14"/>
                         <prefix_q>
                            <identifier ref_name="Init_2" ref="ada://expression_function/Main+2:11/Init_2+4:13" type="null">
                               <sloc line="9" col="9" endline="9" endcol="14"/>
                            </identifier>
                         </prefix_q>
                         <function_call_parameters_ql>
                         </function_call_parameters_ql>
                         <is_prefix_call_q>
                            <is_prefix_call>
                               <sloc line="1" col="1" endline="0" endcol="0"/>
                            </is_prefix_call>
                         </is_prefix_call_q>
                         <is_prefix_notation_q>
                            <not_an_element>
                               <sloc line="1" col="1" endline="0" endcol="0"/>
                            </not_an_element>
                         </is_prefix_notation_q>
                      </function_call>
                   </assignment_expression_q>
                </assignment_statement>
             </body_statements_ql>
             <body_exception_handlers_ql>
             </body_exception_handlers_ql>
          </procedure_body_declaration>
       </unit_declaration_q>
       <pragmas_after_ql>
       </pragmas_after_ql>
    </compilation_unit>

Although our source-code example was very simple, the corresponding XML
representation is quite verbose. This shows that :program:`gnat2xml`
classifies each syntactical element from the source-code and generates
a detailed and precise description of these elements.

Please refer to the
`section on gnat2xml <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-ada-to-xml-converter-gnat2xml>`_
from the GNAT User’s Guide for a detailed discussion on
:program:`gnat2xml`.

gnatpp
------

Pretty-printing refers to the process of formatting the source-code
according to a pre-defined convention. :program:`gnatpp` is used for
pretty-printing of Ada source-code files.

Let's look at this example with messy formatting:

.. code-block:: ada

    PrOcEDuRE Main
                      IS

       FUNCtioN
                             Init_2
                      RETurn
         inteGER                iS
                                        (2);

                    I : INTeger;




         BeGiN
                I              :=        Init_2;
                     ENd;

We now let :program:`gnatpp` correct the formatting of this file by using
this command-line:

.. code-block:: sh

    gnatpp main.adb

:program:`gnatpp` corrects the formatting of the file in place, which now
looks like this:

.. code-block:: ada

    procedure Main is

       function Init_2 return Integer is (2);

       I : Integer;

    begin
       I := Init_2;
    end Main;

We may also process all source-code files from a project at once. For
example:

.. code-block:: sh

    gnatpp -P default.gpr

:program:`gnatpp` has an extensive list of options, which allow for
specifying the formatting of many aspects of the source-code and dealing
with many coding styles. These options are extensively discussed in the
`section on gnatpp <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-gnat-pretty-printer-gnatpp>`_
from the GNAT User’s Guide.

gnatstub
--------

Let's suppose you've created a complex specification of an Ada package.
You may create the corresponding package body by copying and adapting
the content of the package specification. But you may also let
:program:`gnatstub` do the job for you. For example, let's consider the
following package specification:

.. code-block:: ada

    package Aux is

       function Add_One (V : Integer) return Integer;

       procedure Reset (V : in out Integer);

    end Aux;

We can call :program:`gnatstub` and indicate the package specification:

.. code-block:: sh

    gnatstub aux.ads

This generates the file ``aux.adb`` with the following content:

.. code-block:: ada

    pragma Ada_2012;
    package body Aux is

       -------------
       -- Add_One --
       -------------

       function Add_One (V : Integer) return Integer is
       begin
          --  Generated stub: replace with real body!
          pragma Compile_Time_Warning (Standard.True, "Add_One unimplemented");
          return raise Program_Error with "Unimplemented function Add_One";
       end Add_One;

       -----------
       -- Reset --
       -----------

       procedure Reset (V : in out Integer) is
       begin
          --  Generated stub: replace with real body!
          pragma Compile_Time_Warning (Standard.True, "Reset unimplemented");
          raise Program_Error with "Unimplemented procedure Reset";
       end Reset;

    end Aux;

As we can see in this example, not only we have all the elements from the
package specification in the generate package body, but we also have:

    - Headers for each subprogram (as comments);

    - Pragmas and exceptions that prevent us from using unimplemented
      subprograms in our application.

In summary, :program:`gnatstub` creates a good starting point for our
implementation. Please refer to the
`section on gnatstub <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-body-stub-generator-gnatstub>`_
from the GNAT User’s Guide for a detailed discussion on :program:`gnatstub`
and its options.

gnattest
--------

:program:`gnattest` facilitates the creation of unit tests based on
`AUnit <http://docs.adacore.com/live/wave/aunit/html/aunit_cb/aunit_cb.html>`_,
the Ada Unit Testing Framework. In principle, we could create unit tests
based on AUnit by just coding everything *by hand*. However,
:program:`gnattest` saves us time, as it generates all the mechanical code
required to connect the package specification from our project to the
AUnit framework.

In this section, we'll reuse the package specification from the previous
section. Just to recap, this was the specification of the :ada:`Aux`
package:

.. code-block:: ada

    package Aux is

       function Add_One (V : Integer) return Integer;

       procedure Reset (V : in out Integer);

    end Aux;

We start by calling :program:`gnattest` for our project:

.. code-block:: sh

    gnattest -P default.gpr -r


By using the ``-r`` option, :program:`gnattest` recursively creates unit
tests for all package specifications from our project.

The complete generated code can be found in ``obj/gnattest``. We can build
it by calling :program:`GPRbuild` for the ``test_driver`` project that
:program:`gnattest` has generated:

.. code-block:: sh

    gprbuild ./obj/gnattest/harness/test_driver.gpr

We can now run the generated application:

.. code-block:: sh

    ./obj/gnattest/harness/test_runner

If we had implemented the actual unit tests, we'd now see the test
results. However, we haven't implemented them yet. The stub code generated
by :program:`gnattest` reminds us of this fact when running the
``test_runner`` application:

.. code-block:: none

    aux.ads:3:4: error: corresponding test FAILED: Test not implemented. (aux-test_data-tests.adb:44)
    aux.ads:5:4: error: corresponding test FAILED: Test not implemented. (aux-test_data-tests.adb:65)
    2 tests run: 0 passed; 2 failed; 0 crashed.

The next step would be to implement the actual unit tests in the
``obj/gnattest/tests/aux-test_data-tests.adb`` file. Just to show how
the behavior looks like when the test is implemented, we can simply
replace the calls to :ada:`Assert` in that file by :ada:`null`. If we do
this quick change and rebuild the application, we get this message:

.. code-block:: none

    aux.ads:3:4: info: corresponding test PASSED
    aux.ads:5:4: info: corresponding test PASSED
    2 tests run: 2 passed; 0 failed; 0 crashed.

Of course, this latest change was just a quick test. We should now
implement an actual tests where those calls to :ada:`Assert` originally
were. You can find more details on how to do that in the
`AUnit Cookbook <http://docs.adacore.com/live/wave/aunit/html/aunit_cb/aunit_cb.html>`_.
Also, :program:`gnattest` offers many options to configure the test
generation and integrate it to project files. You can find more information
in the
`section on gnattest <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-unit-test-generator-gnattest>`_
from the GNAT User’s Guide.
