GNAT Tools
==========

.. include:: <isopub.txt>

.. include:: <isoamsa.txt>

.. role:: ada(code)
   :language: ada

This chapter presents a brief overview of some of the tools included in the
GNAT Community toolchain.

For further details, please refer to the
`GNAT User's Guide <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn.html>`_.

gnatchop
--------

:program:`gnatchop` renames files to match the file structure and naming
convention expected by the rest of the GNAT toolchain.  The GNAT compiler
expects specifications to be stored in :file:`.ads*` files and
implementations (bodies) to be stored in :file:`.adb` files. It also
expects the file names to correspond to the content of each individual
file. For example, the specification of a package :ada:`Pkg.Child` must be
stored in a file named :file:`pkg-child.ads`.

However, we may have multiple Ada packaged contain in a single
file. Consider a file :file:`example.ada` containing the following:

.. code-block:: ada

    with Ada.Text_IO; use Ada.Text_IO;

    package P is
       procedure Test;
    end P;

    package body P is
       procedure Test is
       begin
          Put_Line("Test passed.");
       end Test;
    end P;

    with P; use P;

    procedure P_Main is
    begin
       P.Test;
    end P_Main;

To compile this code, we call :program:`gnatchop` on the file containing
our source code before we call :program:`gprbuild`:

.. code-block:: sh

    gnatchop example.ada
    gprbuild p_main

This generates source files, extracted from :file:`example_ada`, and builds
the executable binary :file:`p_main` from them. In this example
:program:`gnatchop` created the files :file:`p.ads`, :file:`p.adb`, and
:file:`p_main.adb`.

When we do this, any warnings or errors that the compiler displays
refers to the files generated by :program:`gnatchop`. We can, however,
instruct :program:`gnatchop` to instrument the generated files so the
compiler refers to the original file (:file:`example.ada` in our case)
when displaying messages. We do this by using the ``-r`` switch:

.. code-block:: sh

    gnatchop -r example.ada
    gprbuild p_main

If we had an unused variable in ``example.ada``, the compiler warning
would refer to the line in the original file, not in one of the
generated ones.

For documentation on other switches available for :program:`gnatchop`,
please refer to the `gnatchop chapter
<https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/the_gnat_compilation_model.html#renaming-files-with-gnatchop>`_
of the GNAT User's Guide.

gnatprep
--------

We may require conditional compilation in some situations. For example, we
might need a customized implementation of a package for a specific platform
or need to select a specific version of an algorithm depending on the
requirements of the target environment. A traditional way to achieve this
is using a source-code preprocessor. However, in many cases where
conditional compilation was needed, we can instead use the syntax of the
Ada language or the functionality provided by :program:`GPRbuild` to avoid
using a preprocessor in those cases. The `conditional compilation section
<https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/the_gnat_compilation_model.html#conditional-compilation>`_
of the GNAT User's Guide discusses in details how to do this.

When we encounter a complex case where using a preprocessor is the most
straightforward option, we can use :program:`gnatprep`, which provides a
syntax that reminds us of the C and C++ preprocessor. However, unlike in C
and C++, this syntax is not part of the Ada standard and can only be used
with :program:`gnatprep`. Also, you'll encounter some differences in the
syntax, such as in the example below:

.. code-block:: none

    #if VERSION'Defined and then (VERSION >= 4) then
       --  Implementation for version 4.0 and above...
    #else
       --  Standard implementation for older versions...
    #end if;

In this simple case, we could have used the Ada language directly and
avoided the prepocessor entirely. For example:

.. code-block:: ada

    package Config is
       Version : constant Integer := 4;
    end Config;

    with Config;
    procedure Do_Something is
    begin
       if Config.Version >= 4 then
          null;
          --  Implementation for version 4.0 and above...
       else
          null;
          --  Standard implementation for older versions...
       end if;
    end Do_Something;

But for the sake of illustrating the use of :program:`gnatprep`, let's use
it with the code snippet aboved. This is the complete implementation stored
in file :file:`do_something.org.adb`:

.. code-block:: none

    procedure Do_Something is
    begin
       #if VERSION'Defined and then (VERSION >= 4) then
       --  Implementation for version 4.0 and above...
       null;
       #else
       --  Standard implementation for older versions...
       null;
       #end if;
    end Do_Something;


To preprocess this file and build the application, we call
:program:`gnatprep` followed by :program:`GPRbuild`:

.. code-block:: sh

    gnatprep do_something.org.adb do_something.adb
    gprbuild do_something

If we look at the output file after preprocessing, we see that the
``#else`` implementation was selected by :program:`gnatprep`.  To cause it
to select the newer "version" of the code, we list the symbol in our call
to :program:`gnatprep`, just like what we'd do for C/C++:

.. code-block:: sh

    gnatprep -DVERSION=5 do_something.org.adb do_something.adb

However, a cleaner approach is to create a symbol definition file
containing all symbols found in our implementation. Let's create the file
and name it :file:`prep.def`:

.. code-block:: none

    VERSION := 5

Now we just need to pass it to :program:`gnatprep`:

.. code-block:: sh

    gnatprep do_something.org.adb do_something.adb prep.def
    gprbuild do_something

When we use :program:`gnatprep` as above, the line numbers of the output
file differ from those of the input file.  To preserve line numbers, we can
use one of these command-line switches:

    - ``-b``: replace stripped-out code by blank lines
    - ``-c``: comment-out the stripped-out code

For example:

.. code-block:: sh

    gnatprep -b do_something.org.adb do_something.adb prep.def
    gnatprep -c do_something.org.adb do_something.adb prep.def

When we use one of these options, :program:`gnatprep` ensures that the
output file ``do_something.adb`` has the same line numbering as the
original file (``do_something.org.adb``).

The `gnatprep chapter <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/the_gnat_compilation_model.html#preprocessing-with-gnatprep>`_.
of the GNAT User's Guide contains further details about this tool, such as
how to integrate :program:`gnatprep` with project files for
:program:`GPRbuild` and how to replace symbols without using preprocessing
directives (using the ``$symbol`` syntax).

gnatelim
--------

When creating new applications, we may need to reuse existing frameworks
containing multiple packages. While this approach allows us to quickly
create useful applications, it may result in applications that contain many
unused subprograms. For example, our application may use only two
procedures of a package :ada:`P` that contains 15 procedures and
functions. In this case, our resulting application will contain code for 13
unused procedures or functions. This can especially be a problem in
platforms with strict memory contraints.

GNAT provides the pragma :ada:`Eliminate` to remove unused code. When we
specify this pragma for a subprogram, the compiler doesn't generate code
for that subprogram, reducing the overall code size.  We can use this
pragma manually, but our task is simplified by using :program:`gnatelim`,
which scans source-code files and determines which subprograms can be
safely eliminated.

Let's start with a simple example:

.. code-block:: ada

    package P is
       procedure Test_1;
       procedure Test_2;
    end P;

    with Ada.Text_IO; use Ada.Text_IO;

    package body P is
       procedure Test_1 is
       begin
          Put_Line("Test #1 passed.");
       end Test_1;

       procedure Test_2 is
       begin
          Put_Line("Test #2 passed.");
       end Test_2;
    end P;

.. code-block:: ada

    with P; use P;

    procedure Main_App is
    begin
       P.Test_1;
    end Main_App;

To create a list of unused subprograms for our :ada:`Main_App`, we call
:program:`gnatelim`, providing the file containing the main application
(:file:`main_app.adb` in our case) and the file we want to check for unused
code. In this example:

.. code-block:: sh

    gnatelim -main=main_app.adb p.adb

We get the following output:

.. code-block:: none

    ---------------------------------------------------------
    --  List of unused entities to be placed in gnat.adc.  --
    ---------------------------------------------------------
    pragma Eliminate (P, Test_2, Source_Location => "p.ads:3");

We can then add this output to the configuration pragma file of our
application, :file:`gnat.adc`.  Let's redirect the output of
:program:`gnatelim` and recompile the application:

.. code-block:: sh

    gnatelim -main=main_app.adb p.adb > gnat.adc
    gnatmake main_app.adb

We can also associate :program:`gnatelim` with project files for
:program:`GPRbuild`.

.. todo:: Link to upcoming section on configuration files in
          GPRbuild chapter.

Please refer to the
`gnatelim chapter  <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_and_program_execution.html#reducing-size-of-ada-executables-with-gnatelim>`_
of the GNAT User's Guide for further switches for :program:`gnatprep`.

gnatxref and gnatfind
---------------------

We can use the :program:`gnatxref` and :program:`gnatfind` tools to
retrieve information about individual syntactical elements from our
source-code, such as variable and subprogram declarations. Both tools are
based on the cross-referencing information generated by the compiler and
stored in :file:`.ali` files.

Let's reuse an example from the previous section:

.. code-block:: ada

    package P is
       procedure Test_1;
       procedure Test_2;
    end P;

    with Ada.Text_IO; use Ada.Text_IO;

    package body P is
       procedure Test_1 is
       begin
          Put_Line("Test #1 passed.");
       end Test_1;

       procedure Test_2 is
       begin
          Put_Line("Test #2 passed.");
       end Test_2;
    end P;

.. code-block:: ada

    with P; use P;

    procedure Main_App is
    begin
       P.Test_1;
    end Main_App;

After building the application, we can use :program:`gnatxref` to display
elements from individual files:

.. code-block:: sh

    gnatxref p.adb

This generates the following report:

.. code-block:: none

    Ada                                              package
      Decl:  ada.ads     16:9
      Ref:   p.adb        1:6       1:23
    P                                                package
      Decl:  p.ads        1:9
      Body:  p.adb        3:14
    Put_Line                                         procedure
      Decl:  a-textio.ads         263:14
      Ref:   p.adb        6:7      11:7
    Test_1                                           procedure
      Decl:  p.ads        2:14
      Body:  p.adb        4:14
    Test_2                                           procedure
      Decl:  p.ads        3:14
      Body:  p.adb        9:14
    Text_IO                                          package
      Decl:  a-textio.ads          49:13
      Ref:   p.adb        1:27

This report contains the locations of the declaration and body of package
:ada:`P` and of the declaration and body of the procedures :ada:`Test_1`
and :ada:`Test_2` as well as of the declaration of :ada:`Put_Line` (from
the :ada:`Ada.Test_IO`) package and of its reference in the body of package
:ada:`P`.

We can use :program:`gnatfind` to retrieve all references to a specific
pattern. For example, let's search for all instances of :ada:`Test_1`:

.. code-block:: sh

    gnatfind -r Test_1

This generates the following output:

.. code-block:: none

    p.ads:2:14:           (spec) Test_1
    p.adb:4:14:           (body) Test_1
    main_app.adb:5:6:            Test_1
    p.adb:7:8:                   Test_1

The `chapter on gnatxref and gnatfind <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-cross-referencing-tools-gnatxref-and-gnatfind>`_
of the GNAT User's Guide contains further examples and command-line
switches for these tools.

gnatmem
-------

Memory allocation errors involving mismatches between allocation and
deallocation are a comomn source of memory leaks. To test an application
for memory allocation issues, we use :program:`gnatmem`. This tool monitors
all memory allocations in our application. We use this tool by linking our
application to a special version of the memory allocation library
(:file:`libgmem.a`).

Let's consider this simple example:

.. code-block:: ada

    procedure Simple_Mem is
       I_Ptr : access Integer := new Integer;
    begin
       null;
    end Simple_Mem;

To generate a memory report for this code, we need to:

    - Build the application, linking it to :file:`libgmem.a`;

    - Run the application, which generates an output file (:file:`gmem.out`);

    - Run :program:`gnatmem` to generate a report from :file:`gmem.out`.
      report.

For our example above, we do the following:

.. code-block:: sh

    # Build application using gmem
    gnatmake -g simple_mem.adb -largs -lgmem

    # Run the application and generate gmem.out
    ./simple_mem

    # Call gnatmem to display the memory report based on gmem.out
    gnatmem simple_mem

For this example, :program:`gnatmem` produces the following output:

.. code-block:: none

    Global information
    ------------------
       Total number of allocations        :   1
       Total number of deallocations      :   0
       Final Water Mark (non freed mem)   : 4 Bytes
       High Water Mark                    : 4 Bytes

    Allocation Root # 1
    -------------------
     Number of non freed allocations    :   1
     Final Water Mark (non freed mem)   : 4 Bytes
     High Water Mark                    : 4 Bytes
     Backtrace                          :
       simple_mem.adb:2 simple_mem

This shows all the memory that we allocated and tells us that none of it
was deallocated.

Please refer to the
`chapter on gnatmem <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_and_program_execution.html#the-gnatmem-tool>`_
of the GNAT User's Guide for a more detailed discussion of :program:`gnatmem`.

gnatmetric
----------

We use the GNAT metric tool (:program:`gnatmetric`) to compute various
programming metrics, either for individual files or for our complete
project.

For example, we can compute the metrics of the implementation of the
package :ada:`P` above by running :program:`gnatmetric` as follows:

.. code-block:: sh

    gnatmetric p.adb

This produces the following output:

.. code-block:: none

    Line metrics summed over 1 units
      all lines            : 13
      code lines           : 11
      comment lines        : 0
      end-of-line comments : 0
      comment percentage   : 0.00
      blank lines          : 2

    Average lines in body: 4.00

    Element metrics summed over 1 units
      all statements      : 2
      all declarations    : 3
      logical SLOC        : 5

     2 subprogram bodies in 1 units

    Average cyclomatic complexity: 1.00

Please refer to the
`section on gnatmetric <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-gnat-metrics-tool-gnatmetric>`_
of the GNAT User's Guide for the many switches available for
:program:`gnatmetric`, including the ability to generate of reports in XML
format.

gnatdoc
-------

:program:`GNATdoc` to generates HTML documentation for a project. It scans
the source files in the project and extracts the most important
information, such as package, subprogram and type declarations.

The simplest way for you to use this tool is by providing the name of the
project or calling :program:`GNATdoc` from a directory where a project file
is available:

.. code-block:: sh

    gnatdoc -P some_directory/default.gpr

    # Alternatively, when the :file:`default.gpr` file is in the same directory

    gnatdoc

This command is sufficient to generate a simple list of the packages and
the corresponding API for each. However, in order to create a meaningful
documentation, you can annotate the source code to add a description of
each parameter or field. For example:

.. code-block:: ada

    package P is
    --  Collection of auxiliary subprograms

       function Add_One
         (V : Integer
          --  Coefficient to be increased
         ) return Integer;
       --  @return Coefficient increased by one

    end P;

.. code-block:: ada

    package body P is

       function Add_One (V : Integer) return Integer is
       begin
          return V + 1;
       end Add_One;

    end P;

.. code-block:: ada

    with P; use P;

    procedure Main is

       I : Integer;

    begin
       I := Add_One (0);
    end Main;

In this example, :program:`GNATdoc` extracted the documentation from the
specification of package :ada:`P` and added the description of each element
as a comment in the line below the actual declaration. It was also able to
extract the package description, which we wrote as a comment in the line
right after :ada:`package P is`. Finally, it extracted the documentation of
function :ada:`Add_One` (both the description of the :ada:`V` parameter and
of the return value).

In addition to the approach we've just seen, :program:`GNATdoc` also
supports the tagged format |mdash| commonly found in tools such as Javadoc
|mdash| using the ``@`` syntax. We could rewrite the documentation for
package :ada:`P` as follows:

.. code-block:: ada

    package P is
    -- @summary Collection of auxiliary subprograms

       function Add_One
         (V : Integer
         ) return Integer;
       -- @param V Coefficient to be increased
       -- @return Coefficient increased by one

    end P;

You can control what parts of the source-code :program:`GNATdoc` parses to
extract the documentation. For example, you can specify the ``-b`` option
to request that the package body be parsed for additional documentation.
Or you can use the ``-p`` to request :program:`GNATdoc` to parse the
private part of package specifications. For a complete list of options,
please refer to the `GNATdoc User's Guide
<http://docs.adacore.com/gnatdoc-docs/users_guide/_build/html/index.html>`_.

gnat2xml
--------

:program:`gnat2xml` is a tool for generating an XML representation of the
source-code from a project. This XML representation can be used for
source-code analysis, for example. In order to use the tool, you have
to indicate the project file:

.. code-block:: sh

    gnat2xml -P default.gpr > output.xml

Since the XML representation is written to the standard output by default,
we need to redirect it to a file for storage (as in the example above).
In this case, the ``output.xml`` file contains an XML representation of
the complete source-code of our project.

Alternatively, we can generate a corresponding XML file for each
source-code from our project. In order to do that, we use the
``--output-dir`` option:

.. code-block:: sh

    gnat2xml -P default.gpr --output-dir=out_xml

This command generates XML files and stores them in the ``out_xml``
directory.

Let's consider this simple example:

.. code-block:: ada

    procedure Main is

       function Init_2 return Integer is (2);

       I : Integer;

    begin
       I := Init_2;
    end Main;

For this example, :program:`gnat2xml` generates the following XML
representation:

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8" ?>
    <compilation_unit unit_kind="A_Procedure_Body" unit_class="A_Public_Declaration_And_Body" unit_origin="An_Application_Unit" unit_full_name="Main" def_name="Main" source_file="main.adb">
       <sloc line="2" col="1" endline="10" endcol="9"/>
       <context_clause_elements_ql>
       </context_clause_elements_ql>
       <unit_declaration_q>
          <procedure_body_declaration>
             <sloc line="2" col="1" endline="10" endcol="9"/>
             <is_overriding_declaration_q>
                <not_an_element>
                   <sloc line="1" col="1" endline="0" endcol="0"/>
                </not_an_element>
             </is_overriding_declaration_q>
             <is_not_overriding_declaration_q>
                <not_an_element>
                   <sloc line="1" col="1" endline="0" endcol="0"/>
                </not_an_element>
             </is_not_overriding_declaration_q>
             <names_ql>
                <defining_identifier def_name="Main" def="ada://procedure_body/Main+2:11" type="null">
                   <sloc line="2" col="11" endline="2" endcol="14"/>
                </defining_identifier>
             </names_ql>
             <parameter_profile_ql>
             </parameter_profile_ql>
             <aspect_specifications_ql>
             </aspect_specifications_ql>
             <body_declarative_items_ql>
                <expression_function_declaration>
                   <sloc line="4" col="4" endline="4" endcol="41"/>
                   <is_overriding_declaration_q>
                      <not_an_element>
                         <sloc line="1" col="1" endline="0" endcol="0"/>
                      </not_an_element>
                   </is_overriding_declaration_q>
                   <is_not_overriding_declaration_q>
                      <not_an_element>
                         <sloc line="1" col="1" endline="0" endcol="0"/>
                      </not_an_element>
                   </is_not_overriding_declaration_q>
                   <names_ql>
                      <defining_identifier def_name="Init_2" def="ada://expression_function/Main+2:11/Init_2+4:13" type="null">
                         <sloc line="4" col="13" endline="4" endcol="18"/>
                      </defining_identifier>
                   </names_ql>
                   <parameter_profile_ql>
                   </parameter_profile_ql>
                   <is_not_null_return_q>
                      <not_an_element>
                         <sloc line="1" col="1" endline="0" endcol="0"/>
                      </not_an_element>
                   </is_not_null_return_q>
                   <result_profile_q>
                      <identifier ref_name="Integer" ref="ada://ordinary_type/Standard-1:1/Integer-1:1" type="null">
                         <sloc line="4" col="27" endline="4" endcol="33"/>
                      </identifier>
                   </result_profile_q>
                   <result_expression_q>
                      <parenthesized_expression type="ada://ordinary_type/Standard-1:1/Integer-1:1">
                         <sloc line="4" col="38" endline="4" endcol="40"/>
                         <expression_parenthesized_q>
                            <integer_literal type="universal integer" lit_val="2">
                               <sloc line="4" col="39" endline="4" endcol="39"/>
                            </integer_literal>
                         </expression_parenthesized_q>
                      </parenthesized_expression>
                   </result_expression_q>
                   <aspect_specifications_ql>
                   </aspect_specifications_ql>
                </expression_function_declaration>
                <variable_declaration>
                   <sloc line="6" col="4" endline="6" endcol="15"/>
                   <names_ql>
                      <defining_identifier def_name="I" def="ada://variable/Main+2:11/I+6:4" type="ada://ordinary_type/Standard-1:1/Integer-1:1">
                         <sloc line="6" col="4" endline="6" endcol="4"/>
                      </defining_identifier>
                   </names_ql>
                   <has_aliased_q>
                      <not_an_element>
                         <sloc line="1" col="1" endline="0" endcol="0"/>
                      </not_an_element>
                   </has_aliased_q>
                   <object_declaration_view_q>
                      <subtype_indication>
                         <sloc line="6" col="8" endline="6" endcol="14"/>
                         <has_aliased_q>
                            <not_an_element>
                               <sloc line="1" col="1" endline="0" endcol="0"/>
                            </not_an_element>
                         </has_aliased_q>
                         <has_null_exclusion_q>
                            <not_an_element>
                               <sloc line="1" col="1" endline="0" endcol="0"/>
                            </not_an_element>
                         </has_null_exclusion_q>
                         <subtype_mark_q>
                            <identifier ref_name="Integer" ref="ada://ordinary_type/Standard-1:1/Integer-1:1" type="null">
                               <sloc line="6" col="8" endline="6" endcol="14"/>
                            </identifier>
                         </subtype_mark_q>
                         <subtype_constraint_q>
                            <not_an_element>
                               <sloc line="1" col="1" endline="0" endcol="0"/>
                            </not_an_element>
                         </subtype_constraint_q>
                      </subtype_indication>
                   </object_declaration_view_q>
                   <initialization_expression_q>
                      <not_an_element>
                         <sloc line="1" col="1" endline="0" endcol="0"/>
                      </not_an_element>
                   </initialization_expression_q>
                   <aspect_specifications_ql>
                   </aspect_specifications_ql>
                </variable_declaration>
             </body_declarative_items_ql>
             <body_statements_ql>
                <assignment_statement>
                   <sloc line="9" col="4" endline="9" endcol="15"/>
                   <label_names_ql>
                   </label_names_ql>
                   <assignment_variable_name_q>
                      <identifier ref_name="I" ref="ada://variable/Main+2:11/I+6:4" type="ada://ordinary_type/Standard-1:1/Integer-1:1">
                         <sloc line="9" col="4" endline="9" endcol="4"/>
                      </identifier>
                   </assignment_variable_name_q>
                   <assignment_expression_q>
                      <function_call type="ada://ordinary_type/Standard-1:1/Integer-1:1">
                         <sloc line="9" col="9" endline="9" endcol="14"/>
                         <prefix_q>
                            <identifier ref_name="Init_2" ref="ada://expression_function/Main+2:11/Init_2+4:13" type="null">
                               <sloc line="9" col="9" endline="9" endcol="14"/>
                            </identifier>
                         </prefix_q>
                         <function_call_parameters_ql>
                         </function_call_parameters_ql>
                         <is_prefix_call_q>
                            <is_prefix_call>
                               <sloc line="1" col="1" endline="0" endcol="0"/>
                            </is_prefix_call>
                         </is_prefix_call_q>
                         <is_prefix_notation_q>
                            <not_an_element>
                               <sloc line="1" col="1" endline="0" endcol="0"/>
                            </not_an_element>
                         </is_prefix_notation_q>
                      </function_call>
                   </assignment_expression_q>
                </assignment_statement>
             </body_statements_ql>
             <body_exception_handlers_ql>
             </body_exception_handlers_ql>
          </procedure_body_declaration>
       </unit_declaration_q>
       <pragmas_after_ql>
       </pragmas_after_ql>
    </compilation_unit>

Although our source-code example was very simple, the corresponding XML
representation is quite verbose. This shows that :program:`gnat2xml`
classifies each syntactical element from the source-code and generates
a detailed and precise description of these elements.

Please refer to the
`section on gnat2xml <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-ada-to-xml-converter-gnat2xml>`_
from the GNAT User's Guide for a detailed discussion on
:program:`gnat2xml`.

gnatpp
------

Pretty-printing refers to the process of formatting the source-code
according to a pre-defined convention. :program:`gnatpp` is used for
pretty-printing of Ada source-code files.

Let's look at this example with messy formatting:

.. code-block:: ada

    PrOcEDuRE Main
                      IS

       FUNCtioN
                             Init_2
                      RETurn
         inteGER                iS
                                        (2);

                    I : INTeger;




         BeGiN
                I              :=        Init_2;
                     ENd;

We now let :program:`gnatpp` correct the formatting of this file by using
this command-line:

.. code-block:: sh

    gnatpp main.adb

:program:`gnatpp` corrects the formatting of the file in place, which now
looks like this:

.. code-block:: ada

    procedure Main is

       function Init_2 return Integer is (2);

       I : Integer;

    begin
       I := Init_2;
    end Main;

We may also process all source-code files from a project at once. For
example:

.. code-block:: sh

    gnatpp -P default.gpr

:program:`gnatpp` has an extensive list of options, which allow for
specifying the formatting of many aspects of the source-code and dealing
with many coding styles. These options are extensively discussed in the
`section on gnatpp <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-gnat-pretty-printer-gnatpp>`_
from the GNAT User's Guide.

gnatstub
--------

Let's suppose you've created a complex specification of an Ada package.
You may create the corresponding package body by copying and adapting
the content of the package specification. But you may also let
:program:`gnatstub` do the job for you. For example, let's consider the
following package specification:

.. code-block:: ada

    package Aux is

       function Add_One (V : Integer) return Integer;

       procedure Reset (V : in out Integer);

    end Aux;

We can call :program:`gnatstub` and indicate the package specification:

.. code-block:: sh

    gnatstub aux.ads

This generates the file ``aux.adb`` with the following content:

.. code-block:: ada

    pragma Ada_2012;
    package body Aux is

       -------------
       -- Add_One --
       -------------

       function Add_One (V : Integer) return Integer is
       begin
          --  Generated stub: replace with real body!
          pragma Compile_Time_Warning (Standard.True, "Add_One unimplemented");
          return raise Program_Error with "Unimplemented function Add_One";
       end Add_One;

       -----------
       -- Reset --
       -----------

       procedure Reset (V : in out Integer) is
       begin
          --  Generated stub: replace with real body!
          pragma Compile_Time_Warning (Standard.True, "Reset unimplemented");
          raise Program_Error with "Unimplemented procedure Reset";
       end Reset;

    end Aux;

As we can see in this example, not only we have all the elements from the
package specification in the generate package body, but we also have:

    - Headers for each subprogram (as comments);

    - Pragmas and exceptions that prevent us from using unimplemented
      subprograms in our application.

In summary, :program:`gnatstub` creates a good starting point for our
implementation. Please refer to the
`section on gnatstub <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-body-stub-generator-gnatstub>`_
from the GNAT User's Guide for a detailed discussion on :program:`gnatstub`
and its options.

gnattest
--------

:program:`gnattest` facilitates the creation of unit tests based on
`AUnit <http://docs.adacore.com/live/wave/aunit/html/aunit_cb/aunit_cb.html>`_,
the Ada Unit Testing Framework. In principle, we could create unit tests
based on AUnit by just coding everything *by hand*. However,
:program:`gnattest` saves us time, as it generates all the mechanical code
required to connect the package specification from our project to the
AUnit framework.

In this section, we'll reuse the package specification from the previous
section. Just to recap, this was the specification of the :ada:`Aux`
package:

.. code-block:: ada

    package Aux is

       function Add_One (V : Integer) return Integer;

       procedure Reset (V : in out Integer);

    end Aux;

We start by calling :program:`gnattest` for our project:

.. code-block:: sh

    gnattest -P default.gpr -r


By using the ``-r`` option, :program:`gnattest` recursively creates unit
tests for all package specifications from our project.

The complete generated code can be found in ``obj/gnattest``. We can build
it by calling :program:`GPRbuild` for the ``test_driver`` project that
:program:`gnattest` has generated:

.. code-block:: sh

    gprbuild ./obj/gnattest/harness/test_driver.gpr

We can now run the generated application:

.. code-block:: sh

    ./obj/gnattest/harness/test_runner

If we had implemented the actual unit tests, we'd now see the test
results. However, we haven't implemented them yet. The stub code generated
by :program:`gnattest` reminds us of this fact when running the
``test_runner`` application:

.. code-block:: none

    aux.ads:3:4: error: corresponding test FAILED: Test not implemented. (aux-test_data-tests.adb:44)
    aux.ads:5:4: error: corresponding test FAILED: Test not implemented. (aux-test_data-tests.adb:65)
    2 tests run: 0 passed; 2 failed; 0 crashed.

The next step would be to implement the actual unit tests in the
``obj/gnattest/tests/aux-test_data-tests.adb`` file. Just to show how
the behavior looks like when the test is implemented, we can simply
replace the calls to :ada:`Assert` in that file by :ada:`null`. If we do
this quick change and rebuild the application, we get this message:

.. code-block:: none

    aux.ads:3:4: info: corresponding test PASSED
    aux.ads:5:4: info: corresponding test PASSED
    2 tests run: 2 passed; 0 failed; 0 crashed.

Of course, this latest change was just a quick test. We should now
implement an actual tests where those calls to :ada:`Assert` originally
were. You can find more details on how to do that in the
`AUnit Cookbook <http://docs.adacore.com/live/wave/aunit/html/aunit_cb/aunit_cb.html>`_.
Also, :program:`gnattest` offers many options to configure the test
generation and integrate it to project files. You can find more information
in the
`section on gnattest <https://docs.adacore.com/gnat_ugn-docs/html/gnat_ugn/gnat_ugn/gnat_utility_programs.html#the-unit-test-generator-gnattest>`_
from the GNAT User's Guide.
